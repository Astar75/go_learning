# Практика программирования на Go
---
### Ссылки на полезные материалы:

- Официальные сайты https://go.dev/ и https://golang.org
- Документация и уч. материалы https://go.dev/doc/
- Учебные площадки https://go.dev/learn/

### Инструменты языка 

- go help <команда> - помощь по конкретной команде
- go run main.go - компиляция и запуск файла main.go (. - все файлы текущего каталога)
- go build main.go - компиляция файла main.go (. - все файлы текущего каталога)  
  - -race - с детектором гонки
- go get - скачать все зависимости из интернета
- go test - выполнение всех тестов из текущего каталога
  - -v - подробный вывод
  - -race - с детектором гонки
  - -run <имя теста> - запуск одного теста
  - -bench=. - запуск также и тестов производительности
  - -cover - вывод покрытия кода тестами в процентах
- go env - переменные окружения языка
- go fmt - форматирование кода
- go vet - линтер
- go doc <пакет> - генерирует документацию (. - или без аргументов - для пакета текущего каталога)

### Инструменты профилирования, отладки и другое 

Debugger - отладчик. Обычно ставится вместе с IDE. Ссылка: https://github.com/go-delve/delve

Profiler (профайлер) - находится в пакете `net/http/pprof`, нужен для анализа производительности (профайлер). Требует запуска HTTP-сервера и сопоставления специальных ссылок функциям-обработчикам. Имеет веб- и CLI- интерфейсы. Поддерживается визуализация в виде огненных графиков и обычных графов.

Linter - `golangci-lint` самый быстрый на сегодня набор линтеров под одним зонтиком для комплексной проверки кода.

IDE

- VS Code (https://code.visualstudio.com/)  
- GoLang (https://www.jetbrains.com/go/) платная


## Быстрый старт
Для примера напишем небольшое приложение которое по традиции выводит строку "Hello, World". В моем случае я работаю на Windows и действия будут проводится в этой ОС.

1. Откроем командную строку и перейдем в домашний каталог
`cd %HOMEPATH%`
2. Создадим директорию *hello* и перейдем в нее
```
mkdir hello
cd hello
```
3. Включим отслеживание зависимостей для нашего кода.
```
go mod init example/hello
// go: creating new go.mod: module example/hello
```
4. Далее откроем текстовый редактор, вставим код и сохраним файл с именем `hello.go`

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
} 
```

Здесь мы объявили пакет `main`. Пакет - это способ группировки функций, он состоит из всех файлов в одном каталоге.
Также импортировали стандартный пакет `fmt`, который содержит функции форматирования текста, а так же функции вывода на консоль.
Реализовали функцию `main()` для вывода сообщения на консоль. Она вызывается по умолчанию при запуске main пакета.

5. Далее запустим чтобы увидеть приветствие:
```
go run .
Hello, World!
```


### Добавление зависимостей
Немного разнообразим вывод добавив для примера подключение зависимости из стороннего кода. Для этого изменим код следующим образом.


```go
package main

import "fmt"
import "rsc.io/quote" 

func main() {
  fmt.Println(quote.Go())
  // fmt.Println("Hello, World!")
} 
```

Далее выполним в терминале команду, для подключения зависимостей в `go.mod`.

```
go mod tidy
go: finding module for package rsc.io/quote
go: found rsc.io/quote in rsc.io/quote v1.5.2
```

Остается только запустить и увидеть результат.

```
go run .
Don't communicate by sharing memory, share memory by communicating.
```

## Короткий курс по Go

Простая программа в Go выглядит вот так:
```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, User") 
} 
```
### Пакеты
Каждая программа состоит из пакетов. Программа всегда должна запускаться в пакете main. В данной программе используется импорт пакетов fmt и math/rand. По соглашению в языке имя пакета содержит файлы, начинающегося с оператора package rand. 
```go
package main

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Println("My favorite number is", rand.Intn(10))
}
```
### Импорты
Этот код группирует импорты в круглых скобках (факторизованный оператор импорта). 
Возможно писать импорт пакетов в каждую строчку.
```go
import "fmt"
import "math"
```
Но хороший стиль использовать именно факторизованный оператор импорта.
```go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Now you have %g problems.\n", math.Sqrt(7))
}
```

### Экспортированные имена 
В Go имя экспортируется, если оно начинается с заглавной буквы. Например Pizza - экспортированное имя как и Pi из пакета math.
Имена, которые начинаются с маленькой буквы экспортироваться не будут, а значит не будут доступны с другого пакета.

Например данный код не скомпилируется... 
```go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}
```
...до тех пор пока не заменим `math.pi` до `math.Pi`. 

### Функции
Функция может быть с одним и более аргументами или без аргументов.
В примере `add()` принимает два параметра типа `int`.

```go
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```
Если два или более аргументов функции имеют один и тот же тип, то можно опустить тип во всех параметров кроме последнего. 

Например можно заменить 
```go
func add(x int, y int) int {
}
```
```
на 
```
```go
func add(x, y int) int {
}
```
### Возврат несколько результатов
Функции могут возвращать любое количество результатов.
Функция swap возвращает две строки. 
```go
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
```
### Именованные возвращаемые значения
Возвращаемые значения в Go могут иметь имена. Эти имена следует использовать для документирования значения возвращаемых значений. 
Оператор return без аргументов возвращает именованные возвращаемые значения. Это называется как "голый" возврат. 

Голые операторы возврата следует использовать только в коротких функциях, как в примере, показанном здесь. Они могут ухудшить читаемость длинных функций.

```go
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
```
### Переменные 
Для объявления переменных есть оператор `var`. Тип переменной указывается в конце имени переменной. Оператор `var` может находиться на уровне пакета или функции. В этом примере показаны оба случая: 
```go
package main

import "fmt"

var c, python, java bool

func main() {
	var i int
	fmt.Println(i, c, python, java)
}
```
Так же имеется возможность при создании переменной задать инициализацию. При этом тип можно не указывать. 
```go
package main

import "fmt"

var i, j int = 1, 2

func main() {
	var c, python, java = true, false, "no!"
	fmt.Println(i, j, c, python, java)
}
```
Внутри функций так же доступно создание переменной с присвоением без ключевого слова `var`, так же известное как короткое объявление переменных

```go
package main

import "fmt"

func main() {
	var i, j int = 1, 2
	k := 3
	c, python, java := true, false, "no!"

	fmt.Println(i, j, k, c, python, java)
}
```
### Базовые типы данных
В Go доступны следующие базовые типы данных 

```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point

float32 float64

complex64 complex128
```
В примере ниже показаны примеры нескольких типов, а так же то, что объявления переменных могут быть разложены на блоки в случае с операторами импорта. 

Типы int, uint и uintptr обычно имеет размер 32 бита в 32-битных системах и 64 бита в 64-битных системах.

Используйте int, если нет особой причины использовать размерный или беззнаковый целочисленный тип.
```go
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}
```

### Конвертация типов 
Выражение `T(v)` преобразует значение `V` в тип `T`.
Вот примеры числовых преобразований
```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```
или если сделать проще
```go
i := 42
f := float64(i)
u := uint(f)
```
В отличие от C, в Go назначение элементов разного типа требует явного преобразования. Попробуйте удалить преобразование float64 или uint в примере и посмотрите, что произойдет.
```go
package main

import (
	"fmt"
	"math"
)

func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = f // будет ошибка
	// var z uint = uint(f)
	fmt.Println(x, y, z)
}
```
### Вывод типа
При объявлении переменной без указания явного типа (с использованием синтаксиса `:=` или `var =`синтаксиса выражения) тип переменной выводится из значения в правой части. 
Когда вводится правая часть объявления, новая переменная имеет тот же тип:
```go
var i int
j := i // j - целое число
```
Но когда правая часть содержит нетипизированную числовую константу, новая переменная может быть `int`, `float64` или `complex128` в зависимости от точности константы:
```go
i := 42 // int
f := 3.142 // float64
g := 0.867 + 0.5i // complex128
```

Попробуйте изменить начальное значение переменной v и посмотрите что произойдет

```go
package main

import "fmt"

func main() {
	v := 42 // change me!
	fmt.Printf("v is of type %T\n", v)
}
```
### Константы 

Константы объявляются так же как и переменные но с ключевым словом `const`. Они могут быть символьными, строковыми, логическими или числовыми значениями. Так же они не могут быть объявлены с использованием оператора `:=`.

```go
package main

import "fmt"

const Pi = 3.14

func main() {
	const World = "世界"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
```
Числовые константы представляют собой значения с высокой точностью. Нетипизированная константа принимает тип, необходимый ее контексту. Попробуйте распечатать `needInt(Big)`.  Тип `int` может хранить максимум 64-битное целое число, а иногда и меньше. 

```go
package main

import "fmt"

const (
	// Создаем большое число, сдвигая 1 бит влево на 100 позиций.
	// Другими словами, двоичное число, состоящее из 1 и 100 нулями.  
	Big = 1 << 100
	// Снова сдвинем вправо на 99 позиций, так что в итоге мы получим 1 << 1 или 2.
	Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}

```
